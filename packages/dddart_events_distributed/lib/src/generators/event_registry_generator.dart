/// Code generator for event registry.
library;

// ignore_for_file: deprecated_member_use

import 'package:analyzer/dart/element/element.dart';
import 'package:build/build.dart';
import 'package:dddart_serialization/dddart_serialization.dart';
import 'package:source_gen/source_gen.dart';

/// Builder function for the event registry generator.
Builder eventRegistryBuilder(BuilderOptions options) => LibraryBuilder(
      EventRegistryGenerator(),
      generatedExtension: '.event_registry.g.dart',
    );

/// Generator for event registry that maps event type names to
/// fromJson factories.
class EventRegistryGenerator extends Generator {
  @override
  String? generate(LibraryReader library, BuildStep buildStep) {
    // Find all classes annotated with @Serializable that extend DomainEvent
    final annotatedElements = library.annotatedWith(
      const TypeChecker.fromRuntime(Serializable),
    );

    final eventClasses = <ClassElement>[];

    for (final annotatedElement in annotatedElements) {
      final element = annotatedElement.element;

      if (element is! ClassElement) {
        continue;
      }

      // Check if the class extends DomainEvent
      if (_extendsDomainEvent(element)) {
        eventClasses.add(element);
      }
    }

    // If no event classes found, don't generate anything
    if (eventClasses.isEmpty) {
      return null;
    }

    // Generate the event registry
    return _generateEventRegistry(eventClasses);
  }

  /// Checks if a class extends DomainEvent.
  bool _extendsDomainEvent(ClassElement classElement) {
    ClassElement? current = classElement;

    while (current != null) {
      final supertype = current.supertype;
      if (supertype == null) break;

      final supertypeName = supertype.element.name;

      // Check for DomainEvent
      if (supertypeName == 'DomainEvent') {
        return true;
      }

      current = supertype.element as ClassElement?;
    }

    return false;
  }

  /// Generates the event registry map.
  String _generateEventRegistry(List<ClassElement> eventClasses) {
    final buffer = StringBuffer()
      ..writeln('// Generated event registry')
      ..writeln('// ignore_for_file: type=lint')
      ..writeln()
      ..writeln("import 'package:dddart/dddart.dart';")
      ..writeln();

    // Sort event classes by name for deterministic output
    final sortedClasses = List<ClassElement>.from(eventClasses)
      ..sort((a, b) => a.name.compareTo(b.name));

    buffer
      ..writeln(
        '/// Generated event registry mapping event type names '
        'to fromJson factories.',
      )
      ..writeln('///')
      ..writeln(
        '/// This map is automatically generated by scanning '
        'for @Serializable',
      )
      ..writeln(
        '/// DomainEvent subclasses. Use this registry with '
        'EventBusClient to',
      )
      ..writeln('/// enable automatic deserialization of distributed events.')
      ..writeln(
        'final generatedEventRegistry = '
        '<String, DomainEvent Function(Map<String, dynamic>)>{',
      );

    for (final classElement in sortedClasses) {
      final className = classElement.name;
      buffer.writeln("  '$className': $className.fromJson,");
    }

    buffer.writeln('};');

    return buffer.toString();
  }
}
