/// Maps between domain objects and SQL rows.
///
/// This class provides utility methods for flattening and reconstructing
/// value objects with prefixed column names. The actual serialization
/// and deserialization logic will be generated by the code generator.
class ObjectMapper {
  /// Creates an object mapper.
  const ObjectMapper();

  /// Flattens a JSON map by prefixing nested value object fields.
  ///
  /// Takes a JSON map and flattens any nested maps (representing value objects)
  /// by prefixing their keys with the parent field name.
  ///
  /// Example:
  /// ```dart
  /// final json = {
  ///   'id': '123',
  ///   'totalAmount': {'amount': 100.0, 'currency': 'USD'},
  /// };
  /// final flattened = mapper.flattenValueObject('totalAmount', json['totalAmount']);
  /// // Returns: {'totalAmount_amount': 100.0, 'totalAmount_currency': 'USD'}
  /// ```
  Map<String, Object?> flattenValueObject(
    String prefix,
    Map<String, dynamic> valueObjectJson,
  ) {
    final flattened = <String, Object?>{};

    for (final entry in valueObjectJson.entries) {
      final key = entry.key;
      final value = entry.value;

      // Create prefixed column name
      final columnName = '${prefix}_$key';

      // Recursively flatten nested value objects
      if (value is Map<String, dynamic>) {
        final nestedFlattened = flattenValueObject(columnName, value);
        flattened.addAll(nestedFlattened);
      } else {
        flattened[columnName] = value;
      }
    }

    return flattened;
  }

  /// Reconstructs a value object JSON map from prefixed columns.
  ///
  /// Extracts all columns that start with the given prefix and reconstructs
  /// the original nested JSON structure.
  ///
  /// Example:
  /// ```dart
  /// final row = {
  ///   'id': '123',
  ///   'totalAmount_amount': 100.0,
  ///   'totalAmount_currency': 'USD',
  /// };
  /// final valueObject = mapper.reconstructValueObject('totalAmount', row);
  /// // Returns: {'amount': 100.0, 'currency': 'USD'}
  /// ```
  Map<String, dynamic> reconstructValueObject(
    String prefix,
    Map<String, Object?> row,
  ) {
    final jsonMap = <String, dynamic>{};
    final prefixWithUnderscore = '${prefix}_';

    // Extract all columns that start with the prefix
    for (final entry in row.entries) {
      final columnName = entry.key;
      if (columnName.startsWith(prefixWithUnderscore)) {
        // Remove the prefix to get the field path
        final fieldPath = columnName.substring(prefixWithUnderscore.length);

        // Handle nested paths (e.g., 'address_city' -> {'address': {'city': ...}})
        _setNestedValue(jsonMap, fieldPath, entry.value);
      }
    }

    return jsonMap;
  }

  /// Sets a value in a nested map structure using a dot-separated path.
  void _setNestedValue(
    Map<String, dynamic> map,
    String path,
    Object? value,
  ) {
    final parts = path.split('_');

    if (parts.length == 1) {
      // Simple field - set directly
      map[parts[0]] = value;
    } else {
      // Nested field - create intermediate maps as needed
      var current = map;
      for (var i = 0; i < parts.length - 1; i++) {
        final part = parts[i];
        if (!current.containsKey(part)) {
          current[part] = <String, dynamic>{};
        }
        current = current[part] as Map<String, dynamic>;
      }
      current[parts.last] = value;
    }
  }
}
