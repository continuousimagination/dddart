# Requirements Document: Fix AWS Cognito OAuth Support

## Introduction

The current `CognitoAuthProvider` in dddart_rest_client attempts to use OAuth 2.0 Device Authorization Grant (device flow), but AWS Cognito does not support this flow. This specification defines the correct implementation using OAuth 2.0 Authorization Code flow with PKCE (Proof Key for Code Exchange), which is the standard flow supported by Cognito for public clients.

The Authorization Code flow with PKCE provides:
- Cognito Hosted UI for all user management (login, signup, password reset, MFA)
- Secure authentication without client secrets (PKCE provides security)
- Support for multiple platforms through pluggable callback strategies
- Automatic token refresh using refresh tokens

### Platform Support Strategy

This implementation uses a **pluggable callback strategy** pattern to support different platforms:

- **CLI/Desktop Apps**: Use `LocalhostCallbackStrategy` (default) - starts temporary local server, opens browser automatically
- **Web Apps**: Use `ManualCallbackStrategy` - user copies authorization code from browser
- **Mobile Apps**: Implement `CustomSchemeCallbackStrategy` - uses platform-specific URL schemes (myapp://)
- **Custom Scenarios**: Implement your own `OAuthCallbackStrategy`

This approach keeps `dddart_rest_client` platform-agnostic while providing excellent out-of-the-box support for the most common use case (CLI/desktop apps).

## Glossary

- **Authorization Code Flow**: OAuth 2.0 flow where the client receives an authorization code that is exchanged for tokens. Requires user interaction in a browser.
- **PKCE (Proof Key for Code Exchange)**: Security extension for OAuth that allows public clients (without client secrets) to securely perform authorization code flow.
- **Code Verifier**: Random string generated by the client, used in PKCE to prove the client that started the flow is the same one exchanging the code.
- **Code Challenge**: SHA-256 hash of the code verifier, sent in the authorization request.
- **Cognito Hosted UI**: AWS Cognito's built-in web interface for user authentication, registration, password reset, and MFA.
- **Redirect URI**: URL where Cognito sends the authorization code after user authentication. Format depends on the callback strategy.
- **State Parameter**: Random value used to prevent CSRF attacks by verifying the authorization response matches the request.
- **ID Token**: JWT containing user identity claims (sub, email, etc.) issued by Cognito alongside the access token.
- **OAuth Callback Strategy**: Pluggable component that handles receiving the authorization code from Cognito. Different strategies support different platforms.
- **Localhost Callback**: Strategy that starts a temporary local HTTP server to receive the authorization code (for CLI/desktop).
- **Manual Callback**: Strategy where the user manually copies the authorization code from the browser (works on any platform).
- **Custom Scheme Callback**: Strategy that uses platform-specific URL schemes like `myapp://` (for mobile apps).

## Requirements

### Requirement 1

**User Story:** As a developer using dddart_rest_client, I want to authenticate users with AWS Cognito using the Authorization Code flow with PKCE, so that users can log in through Cognito's Hosted UI without my application needing to handle credentials.

#### Acceptance Criteria

1. WHEN initiating login THEN the system SHALL generate a random code verifier for PKCE
2. WHEN generating a code verifier THEN the verifier SHALL be a cryptographically random string of 43-128 characters from the unreserved character set [A-Z, a-z, 0-9, -, ., _, ~]
3. WHEN a code verifier is generated THEN the system SHALL compute the code challenge as Base64URL(SHA256(code_verifier))
4. WHEN building the authorization URL THEN the system SHALL include client_id, response_type=code, redirect_uri, scope, state, code_challenge, and code_challenge_method=S256
5. WHEN the authorization URL is built THEN the system SHALL use the Cognito domain's /oauth2/authorize endpoint

### Requirement 2

**User Story:** As a developer, I want to use different callback strategies for different platforms, so that my application works whether it's a CLI tool, web app, or mobile app.

#### Acceptance Criteria

1. WHEN creating a CognitoAuthProvider THEN the system SHALL accept an optional callbackStrategy parameter
2. WHEN no callbackStrategy is provided THEN the system SHALL default to LocalhostCallbackStrategy
3. WHEN a custom callbackStrategy is provided THEN the system SHALL use that strategy to obtain the authorization code
4. WHEN the callback strategy completes THEN the system SHALL receive the authorization code and state parameter
5. WHEN the callback strategy fails THEN the system SHALL throw an AuthenticationException with details

### Requirement 3

**User Story:** As a CLI/desktop app developer, I want automatic browser-based authentication with a local callback server, so that users get the best possible experience without manual code copying.

#### Acceptance Criteria

1. WHEN using LocalhostCallbackStrategy THEN the system SHALL start a temporary local HTTP server on the configured port
2. WHEN the HTTP server starts THEN the system SHALL attempt to open the authorization URL in the user's default browser
3. WHEN the browser cannot be opened automatically THEN the system SHALL print the authorization URL for manual opening
4. WHEN the HTTP server receives a request to the callback path THEN the system SHALL extract the authorization code and state from query parameters
5. WHEN the authorization code is received THEN the system SHALL send an HTML response to the browser indicating success or failure
6. WHEN the authorization code is received THEN the system SHALL close the temporary HTTP server
7. WHEN the state parameter doesn't match THEN the system SHALL throw an AuthenticationException indicating possible CSRF attack

### Requirement 4

**User Story:** As a web app or cross-platform developer, I want a manual callback strategy where users copy the authorization code, so that authentication works even when automatic browser integration isn't possible.

#### Acceptance Criteria

1. WHEN using ManualCallbackStrategy THEN the system SHALL print the authorization URL for the user to open
2. WHEN using ManualCallbackStrategy THEN the system SHALL print instructions to copy the authorization code from the browser
3. WHEN using ManualCallbackStrategy THEN the system SHALL prompt the user to paste the authorization code
4. WHEN the user provides the authorization code THEN the system SHALL extract the code and state from the full callback URL or just the code parameter
5. WHEN the state parameter doesn't match THEN the system SHALL throw an AuthenticationException indicating possible CSRF attack

### Requirement 5

**User Story:** As a developer, I want to exchange the authorization code for tokens, so that my application can make authenticated API requests on behalf of the user.

#### Acceptance Criteria

1. WHEN exchanging an authorization code THEN the system SHALL POST to the Cognito domain's /oauth2/token endpoint
2. WHEN exchanging an authorization code THEN the request SHALL include grant_type=authorization_code, client_id, code, redirect_uri, and code_verifier
3. WHEN the token exchange succeeds THEN the response SHALL contain access_token, id_token, refresh_token, expires_in, and token_type
4. WHEN the token exchange fails THEN the system SHALL throw an AuthenticationException with the error details
5. WHEN tokens are received THEN the system SHALL store them in the credentials file

### Requirement 6

**User Story:** As a developer, I want to extract user identity from Cognito's ID token, so that I can link Cognito users to my application's user records.

#### Acceptance Criteria

1. WHEN tokens are received from Cognito THEN the system SHALL store the ID token alongside the access and refresh tokens
2. WHEN the application requests the Cognito sub (user ID) THEN the system SHALL decode the ID token and extract the sub claim
3. WHEN decoding the ID token THEN the system SHALL verify the token has three parts (header, payload, signature) separated by dots
4. WHEN the ID token is missing the sub claim THEN the system SHALL throw an AuthenticationException
5. WHEN the application requests all ID token claims THEN the system SHALL decode the ID token and return all claims as a map

### Requirement 7

**User Story:** As a developer, I want to refresh expired access tokens using the refresh token, so that users don't have to re-authenticate frequently.

#### Acceptance Criteria

1. WHEN refreshing tokens THEN the system SHALL POST to the Cognito domain's /oauth2/token endpoint
2. WHEN refreshing tokens THEN the request SHALL include grant_type=refresh_token, client_id, and refresh_token
3. WHEN the refresh succeeds THEN the response SHALL contain a new access_token and expires_in
4. WHEN the refresh response includes a new id_token THEN the system SHALL store the new ID token
5. WHEN the refresh response does NOT include a new id_token THEN the system SHALL preserve the existing ID token
6. WHEN the refresh fails THEN the system SHALL throw an AuthenticationException indicating the user needs to login again

### Requirement 8

**User Story:** As a developer, I want the redirect URI and callback configuration to be flexible, so that I can adapt to different deployment scenarios and platform requirements.

#### Acceptance Criteria

1. WHEN using LocalhostCallbackStrategy THEN the system SHALL accept an optional port parameter (default: 8080)
2. WHEN using LocalhostCallbackStrategy THEN the system SHALL accept an optional path parameter (default: '/callback')
3. WHEN using LocalhostCallbackStrategy THEN the redirect URI SHALL be constructed as 'http://localhost:{port}{path}'
4. WHEN using ManualCallbackStrategy THEN the redirect URI SHALL be configurable to match the Cognito app client configuration
5. WHEN starting the local callback server THEN the system SHALL bind to localhost (127.0.0.1) only, not all interfaces

### Requirement 9

**User Story:** As a developer, I want clear error messages when authentication fails, so that users can understand what went wrong and how to fix it.

#### Acceptance Criteria

1. WHEN Cognito returns an error in the authorization callback THEN the system SHALL throw an AuthenticationException with the error and error_description
2. WHEN the state parameter doesn't match THEN the error message SHALL indicate "State mismatch - possible CSRF attack"
3. WHEN no authorization code is received THEN the error message SHALL indicate "No authorization code received"
4. WHEN token exchange fails THEN the error message SHALL include the response body from Cognito
5. WHEN the ID token format is invalid THEN the error message SHALL indicate "Invalid ID token format"

### Requirement 10

**User Story:** As a CLI/desktop developer using LocalhostCallbackStrategy, I want the local callback server to display a user-friendly page in the browser, so that users know whether authentication succeeded or failed.

#### Acceptance Criteria

1. WHEN authentication succeeds THEN the browser SHALL display a success page with a green checkmark and message "Authentication Successful!"
2. WHEN authentication succeeds THEN the success page SHALL instruct the user to return to the terminal
3. WHEN authentication fails THEN the browser SHALL display an error page with a red X and message "Authentication Failed"
4. WHEN authentication fails THEN the error page SHALL instruct the user to check the terminal for details
5. WHEN the callback server receives a request to a non-callback path THEN the server SHALL return HTTP 404

### Requirement 11

**User Story:** As a developer, I want the CognitoAuthProvider to work seamlessly with the existing AuthProvider interface, so that I can switch between self-hosted and Cognito authentication without changing my application code.

#### Acceptance Criteria

1. WHEN using CognitoAuthProvider THEN the provider SHALL implement the AuthProvider interface
2. WHEN calling getAccessToken() THEN the provider SHALL return a valid access token, refreshing if necessary
3. WHEN calling login() THEN the provider SHALL execute the Authorization Code flow with PKCE using the configured callback strategy
4. WHEN calling logout() THEN the provider SHALL delete the stored credentials
5. WHEN calling isAuthenticated() THEN the provider SHALL return true if valid credentials exist, false otherwise

### Requirement 12

**User Story:** As a developer, I want to configure the OAuth scopes requested from Cognito, so that I can request only the permissions my application needs.

#### Acceptance Criteria

1. WHEN building the authorization URL THEN the system SHALL include scope parameter with default value "openid email profile"
2. WHEN the application needs custom scopes THEN the system SHALL accept an optional scopes parameter in the constructor
3. WHEN custom scopes are provided THEN the system SHALL use those scopes instead of the default
4. WHEN multiple scopes are provided THEN the system SHALL join them with spaces in the authorization URL
5. WHEN no scopes are provided THEN the system SHALL use the default scopes

### Requirement 13

**User Story:** As a developer, I want comprehensive tests for the Cognito authentication flow, so that I can be confident the implementation works correctly across different callback strategies.

#### Acceptance Criteria

1. WHEN testing token storage THEN the tests SHALL verify ID tokens are stored alongside access and refresh tokens
2. WHEN testing token refresh THEN the tests SHALL verify the ID token is preserved when Cognito doesn't return a new one
3. WHEN testing token refresh THEN the tests SHALL verify a new ID token is used when Cognito returns one
4. WHEN testing getCognitoSub() THEN the tests SHALL verify the sub claim is correctly extracted from the ID token
5. WHEN testing getIdTokenClaims() THEN the tests SHALL verify all claims are correctly extracted from the ID token
6. WHEN testing LocalhostCallbackStrategy THEN the tests SHALL verify the local server starts, receives callbacks, and shuts down properly
7. WHEN testing ManualCallbackStrategy THEN the tests SHALL verify the user prompt and code extraction work correctly

## Non-Requirements

1. **Device Flow Support**: AWS Cognito does not support OAuth 2.0 Device Authorization Grant. This spec does not attempt to implement device flow for Cognito.

2. **Implicit Flow**: While Cognito supports Implicit flow, it is less secure than Authorization Code + PKCE and is not recommended for modern applications.

3. **Client Credentials Flow**: This flow is for machine-to-machine authentication and is not applicable for user authentication.

4. **Custom Callback Server UI Frameworks**: The LocalhostCallbackStrategy provides minimal HTML responses. Integration with UI frameworks or custom branding is out of scope.

5. **Multiple Concurrent Logins**: The implementation supports one login flow at a time per application instance. Concurrent logins from the same instance are not supported.

6. **Browser Selection**: The LocalhostCallbackStrategy uses the system's default browser. Custom browser selection is out of scope.

7. **Headless Authentication**: The flow requires a browser for user interaction. Fully automated/headless authentication is not supported.

8. **Mobile Platform-Specific Implementation**: While the architecture supports mobile through custom callback strategies, implementing platform-specific URL scheme handlers for iOS/Android is out of scope for this spec. Mobile developers should implement `CustomSchemeCallbackStrategy` using platform-specific packages.

## Success Criteria

The implementation will be considered successful when:

1. Users can authenticate with AWS Cognito through the Cognito Hosted UI using any supported callback strategy
2. CLI/desktop apps get automatic browser-based authentication with LocalhostCallbackStrategy (default)
3. Web and other platforms can use ManualCallbackStrategy for manual code entry
4. The callback strategy pattern is extensible for custom implementations (e.g., mobile URL schemes)
5. Access tokens, refresh tokens, and ID tokens are correctly stored and managed
6. Token refresh works automatically when access tokens expire
7. User identity can be extracted from ID tokens
8. All existing tests pass and new tests cover the Cognito-specific functionality and callback strategies
9. The implementation works on macOS, Windows, and Linux
10. Error messages are clear and actionable
11. The CognitoAuthProvider is a drop-in replacement for DeviceFlowAuthProvider in terms of the AuthProvider interface
12. Documentation clearly explains which callback strategy to use for different platforms
